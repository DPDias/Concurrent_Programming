/*
 * This Java source file was generated by the Gradle 'init' task.
 */
import com.sun.org.apache.xpath.internal.operations.Equals;
import org.junit.Assert;
import org.junit.Test;

import java.lang.reflect.Array;
import java.util.List;
import java.util.function.Function;
import java.util.function.Supplier;

import static java.util.Arrays.asList;
import static org.junit.Assert.*;

public class AppTest {

    public static class Contentor{
        int pos;

        public Contentor(int pos) {
            this.pos = pos;
        }
    }

    @Test
    public void getSameInstance2ThreadsTest() throws InterruptedException{
        TransferQueue <Contentor> tq = new TransferQueue<>();
        Contentor msg = new Contentor(-1);

        //Coloca uma msg com método Transfer
        Thread a = new Thread(() -> {
            try {
                tq.transfer(msg, 10000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        Contentor [] answer = new Contentor[1];

        //Vai buscar uma MSG e guarda no array answer
        Thread b = new Thread(() -> {
            try {

                tq.take(10000, answer);

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        a.start();
        b.start();

        a.join();
        b.join();

        //verifica se a answer que a Thread foi buscar no Take é a mesma instãncia que foi colocada com o Transfer
        Assert.assertEquals(msg, answer[0]);
    }

    @Test
    public void putSameInstanceTest() throws InterruptedException {
        TransferQueue <Contentor> tq = new TransferQueue<>();
        Contentor msg = new Contentor(-1);
        Thread a = new Thread(() -> {
                tq.put(msg);
        });
        Contentor [] answer = new Contentor[1];
        Thread b = new Thread(() -> {
            try {
                tq.take(10000, answer);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        a.start();
        b.start();

        a.join();
        b.join();

        Assert.assertEquals(msg, answer[0]); //validar que a thread foi buscar o mesmo objecto que foi colocado pelo PUT
    }

    @Test
    public void putDontBlockTest() throws InterruptedException {
        TransferQueue <Contentor> tq = new TransferQueue<>();


        // Thread A que irá bloquear-se mas fica na primeira posição da fila
        Contentor msgTra = new Contentor(0);
        Thread a = new Thread(() -> {
            try {
                tq.transfer(msgTra, 100000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        // Thread B que não se bloqueia e a msg fica na segunda posição da fila
        Contentor msgPut = new Contentor(1);
        Thread b = new Thread(() -> {
            tq.put(msgPut);
        });

        // Thread C que vai buscar a primeira mensagem
        Contentor [] answer = new Contentor[1];
        Thread c = new Thread(() -> {
            try {

                tq.take(100000, answer);

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        //Thread D que vai buscar a mensagem colocada pelo o PUT
        Thread d = new Thread(() -> {
            try {
                tq.take(100000, answer);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        a.start();
        b.start();
        Thread.sleep(2000);
        Assert.assertTrue(a.isAlive());         //observamos que a thread A, bloqueou no await, visto que usou o método Transfer
        Assert.assertFalse(b.isAlive());        //observamos que a thread B, não bloqueou visto que usou o método PUT
        c.start();
        Thread.sleep(2000);
        d.start();

        a.join();
        b.join();
        d.join();

        Assert.assertEquals(msgPut, answer[0]);  //validar que a última thread foi buscar o mesmo objecto que foi colocado pelo PUT
    }

    @Test
    public void timeoutTest() throws InterruptedException {
        TransferQueue <Contentor> tq = new TransferQueue<>();
        Contentor msg = new Contentor(-1);

        boolean [] timeout = new boolean[2];

        Thread a = new Thread(() -> {
            try {
                if(tq.transfer(msg, 1000))
                    timeout[0] = true;
                else timeout[0] = false;
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        Contentor [] answer = new Contentor[1];
        Thread b = new Thread(() -> {
            try {

                if(tq.take(1000, answer))
                    timeout[1] = true;
                else timeout[1] = false;

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        a.start();
        Thread.sleep(1001);
        b.start();

        a.join();
        b.join();

        Assert.assertTrue(timeout[0] && timeout[1]);
    }

    @Test
    public void interruptTest() throws InterruptedException {
        TransferQueue <Contentor> tq = new TransferQueue<>();
        Contentor msg = new Contentor(-1);

        boolean [] interrupt = new boolean[]{false, false};

        Thread a = new Thread(() -> {
            try {
                tq.transfer(msg, 10000);
            } catch (InterruptedException e) {
                interrupt[0] = true;
            }
        });

        Contentor [] answer = new Contentor[1];
        Thread b = new Thread(() -> {
            try {
                tq.take(10000, answer);
            } catch (InterruptedException e) {
                interrupt[1] = true;
            }
        });

        a.start();
        a.interrupt();
        b.start();
        b.interrupt();

        a.join();
        b.join();

        Assert.assertTrue(interrupt[0] && interrupt[1]);
    }

    @Test
    public void transferQueueTest() throws InterruptedException {
        TransferQueue <Contentor> tq = new TransferQueue<>();
        Thread [] threads = new Thread[2000];
        Contentor [] msg = new Contentor[1000];
        Supplier <Contentor> [] takes = new Supplier[1000];
        int idxTakes = 0;

        for(int i = 0; i < msg.length; i++)
            msg[i] = new Contentor(i);

        for(int i = 0; i < threads.length/2 ; i++) {
            Contentor arg = msg[i];
            threads[i] = new Thread(() -> {
                try {
                    tq.transfer(arg, 100000);
                } catch (InterruptedException e) {
                    System.out.println(e.getMessage());
                }
            });
        }

        for(int i = threads.length/2; i < threads.length ; i++) {
            Contentor [] result = new Contentor[1];
            takes[idxTakes++] = ()->result[0];
            threads[i] = new Thread(() -> {
                try {
                    tq.take(100000, result);
                } catch (InterruptedException e) {
                    System.out.println(e.getMessage());
                }
            });

        }

        for(Thread i : threads)
            i.start();

        for(Thread i : threads)
            i.join();

        List<Contentor> messages = asList(msg);
        for(Supplier<Contentor> response : takes)
            Assert.assertTrue(messages.contains(response.get()));
    }
}
